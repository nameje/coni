# 과정
1. 인간이 하는 일의 방식: 데이터 추출 -> 분석 -> 종합 및 보고서 와 같은 과정으로 세분화한 작업을 순차적으로 진행
2. 인공지능에게 일을 시킬때도 동일한 방식으로 수행하도록 진행
   - 인공지능이 한번에 보고서를 작성하도록 하는 방식의 결과 만족도는 10~50%(개인적인 느낌)
   - 세분화시켜서 작은 단위의 작업을 수행 시 결과 만족도는 90~100% + @(경우에 따라 다름)
   - 그렇다면 세분화된 작은 단위(task)를 순차적으로 시킬경우 만족도를 유지
   -> 작업을 stage, phase 단위로 묶음으로 진행시 만족도는 발산하지 않을까?(개인적의견)
1. 그렇다면 작업을 작은 단위로 분할시키는 것도 인공지능에게 맡기면 모든 과정을 자동화하는게 가능함.
2. gemini cli와 같은 에이전트 방식이 아직 공개되기전, 이 과정을 llm 대화창을 이용해 수동으로 진행
   - 플래너, 익스큐터, 프롬프트 엔지니어의 역할 마다 각각의 대화창을 사용(입력 데이터의 노이즈를 억제하기 위함)
   - 사용자의 지시 목적에 부합하는 결과물 도출을 위해서는 모든 과정에 사용자의 목적이 녹아 들 수 있도록 해야함. -> 플래너는 사용자의 지시내용과 이전과정 진행사항 등을 입력 데이터로 활용, 익스큐터에게는 해야할일의 이유, 목적을 플래너가 작업 내용과 함께 계획, 프롬프트 엔지니어는 phase, stage의 계획 내용과 함께 현재 task를 위한 프롬프트를 작성 -> 모든 작업 과정의 일관성을 유지
   - 플래너는 주어진 자료(assets)와 진행과정 및 결과물에 사용자의 노하우가 담긴 가이드라인, 작업 과정에서 발생한 자료(workspace)를 바탕으로 다음 작업들에 익스큐터에게 입력으로 활용할 자료들을 작업 내용에 맞게 계획.
   -> 위와 같은 방식을 stage, phase의 단계로 확장 시 구조가 인공신경망과 유사한 구조로 생각이 들음.
   인공신경망 비유 표
   
| 지침서                     | 인공신경망 비유 |
| ----------------------- | -------- |
| 지시내용, assets, guideline | 입력층      |
| phase, stage            | 은닉층 레이어  |
| 마지막 phase의 stage        | 출력층      |
| task                    | 노드       |
| chain of execution      | 가중치      |
1. 초기 이렇게 만들어진 결과물은 한국어 기준 36,000여개의 단어, 150,000여개의 글자수(워드에서 폰트11로 111페이지 분량)의 방대한 양의 글을 작성.
2. 작성된 내용은 일관성있고, 깊이 수준은 전문가 수준과 동급 또는 그 이상
3. 가이드라인을 결과물 표현, 데이터 분석의 방법 등 각 목적에 맞게 분리하고, 가이드 수준을 높일 수록 결과물의 만족도 및 전문 수준은 향상됨.
4. 이 과정을 코드로 만들어 봐야겠다는 생각을 하게됨.
5. 그렇지만 인공지능의 기본 성능을 따라가기 때문에 인공지능이 하지 못하는것을 하라고 지시할 수는 없음.
6. 2주 전 gemini cli를 사용해보고 바로 위 내용이 코드를 만들지 않고도 gemini cli가 스스로 할수 있겠다고 생각함.
7. gemini cli에게 작업계획을 phase, stage, task 단위로 작성해보도록하고, 그에 맞게 진행해보게 하니 스스로 결과물까지 자동 진행.
8. gemini.md를 활용하면 모든 과정을 사용자 지시만 입력하는 것으로 가능할 것을 기대로 이 행동규범을 작성

# 문제점
1. 초기 gemini 2.5 pro preview 버전에서는 출력 토큰에 대한 제한없이 최대한의 토큰을 사용할 수 있었지만, 현재의 gemini 2.5 pro에서는 출력 토큰을 최대로 사용하기가 어려워짐. 특히 gemini cli의 경우 출력의 제한이 있는 것 같다고 느껴짐
2. 출력의 제한이 생기게 되어 workspace에서 충분한 사고과정이 필요한데, 그러기 위해서는 phase와 stage 단계를 충분히 늘려야함.(현재 제공된 단계는 토큰 사용량이 너무 많아 기본적인 작동 환경으로 세팅)
3. 현재 gemini 뿐만 아니라 다른 모델들도 agent 시스템(행동계획 및 진행)에 맞게 모델의 성향이 사고보다는 행동을 우선으로 답하는 경향이 심해져 강제로 사고의 방법, 방향, 철학 등을 주입해야함.
4. gemini cli와 같은 구조에서는 오케스트레이터가 모든 계획 및 작업의 내용을 컨텍스트로 활용하게되어 입력 토큰이 불필요하게 발생.(지침서에서 오케스트레이터는 규칙에 따른 진행만 관리하면되어서 모든 작업 내용, 과정들을 알고 있을 필요는 없음. 진행관리가 가능한 작은 성능의 모델을 사용하던가  오히려 코드로 짜여진 구조가 적은 토큰 사용으로 동일 결과물을 생성하는게 가능함.)

# 확장 가능성
1. mcp를 활용하여 llm모델을 mcp 서버를 경유하도록 만들어 각각의 에이전트를 에이전트로 연결하고, 각 통신은 db, workspace 등의 데이터로만 활용.(이 경우 프롬프트엔지니어가 필요) a2a가 가능한지는 모르겠지만 a2a로 또다른 cli를 연결할 수 있다면 a2a 활용도 가능.
2. 도구관련 내용에 mcp를 활용하는 내용을 추가하여 task 시 도구를 활용하도록 할 수 있으면 특정 업무들은 mcp를 활용한 자동화가 가능
3. task단의 익스큐터를 하위의 cli로 대체하여 동일한 행동규범을 행하는 에이전트로 활용한다면 이중의 구조로 작동하는 에이전트로 발전.(인간의 조직과 유사한 형태. 이 행동규범으로 작동하는 하나의 인공신경망 에이전트를 한명의 인간으로 대체한다면 조직사회에서의 상위의 명령계층과 하위의 수행계층으로 볼 수 있을거 같음.)
4. 결과물 단위의 연속적인 작업이 있을 경우 이를 구조화해 연속적인 역할의 에이전트 집단을 구성할 수도 있음.
# 생각
1. 인공신경망에 비유한 이 행동규범의 구조의 확장 가능성을 실제 AI 인공신경망에 적용한다면 연속적이거나 상하위 계층의 인공신경망으로 작용할 수 있지 않을까?