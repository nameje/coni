
| korean                                                          | english                                                  |
| --------------------------------------------------------------- | -------------------------------------------------------- |
| [ko](https://github.com/nameje/coni/blob/main/README_korean.md) | [en](https://github.com/nameje/coni/blob/main/README.md) |

# 사용방법(작업영역 폴더에서 구성하는 것을 권장)

## gemini cli(사전에 [gemini cli 설치](https://github.com/google-gemini/gemini-cli))

> claude code와 같이 sub-agent가 적용되지 않아 토큰발생량이 많아 발생하는 문제(속도가 느림)들이 있습니다.(경우에 따라 프로젝트의 하나의 run 동안 입력으로 최대 5억 이상의 토큰 사용) 이 문제는 [gemini-cli: issues(#5000)](https://github.com/google-gemini/gemini-cli/issues/5000) 제기하였으며, 현재는 별도 방식을 통해 sub-agent로 구성하였습니다.

1. gemini를 실행하기 전 아래의 설정이 필요합니다.
	- 작업영역 폴더에 agnet_system 하위 폴더 및 파일 붙여넣기
	- data/ 폴더에 작업 관리 자료 붙여넣기
	- guidelines/ 폴더에 작업관련 가이드라인과 에이전트를 위한 페르소나(claude code에서의 sub-agent 구성 파일도 포함) 붙여넣기(각 작업성격에 맞추어서 플래너는 작업에 맞는 가이드라인과 페르소나를 제공해줌. 페스소나의 갯수 제한 없음.)
	- settings/ 폴더에 mcp_list 작성(ai가 사용할 mcp에 대해 설명과 방법등을 명시. 기존 ai를 활용하여 작성하여도 됩니다.)
	- settings/ 폴더에 set_phases 작성: 최종결과까지의 과정이 작은단위의 결과물의 연결인 경우. 하나의 결과물을 원할 경우 phase는 하나만 작성.
	- settings/ 폴더에 set_stages 작성: 결과물 단위의 진행 단계 설정. 특별히 요구할 사항이 없는 경우 기본 설정된 내용으로 진행.
2. 위 설정 후 작업영역 폴더에서 `gemini` 실행.(별도 권한 설정을 하지 않을 경우 `gemini -y`)
3. 요청사항 작성 후 '코니해' 라고 지시.

## claude code(사전에 [claude code 설치](https://www.anthropic.com/claude-code))

> claude code는 테스트 결과 sub_agent로의 위임이 성공적으로 진행됨. claude code의 실행환경에 맞추어서 일부 수정 예정. 또는 gemini cli를 기준으로 일부 작업 수행을 claude code로 수행할 수 있도록 수정 예정.

---
run의 진행에 따라 이미 진행한 run_id의 결과물에 대해 추가적인 업데이트 이력 관리 등 프로젝트의 진행을 관리할 수 있습니다.


---
# 1. 행동규범(이하 coni), 그 시작에 대하여

과거, 지능을 가진 '에이전트'를 만드는 것은 컴퓨터의 언어인 '코드'를 다루는 개발자들만의 영역이었습니다. 하지만 이제 우리는 놀라운 시대의 전환을 목격하고 있습니다. 바로 인간이 가장 쉽게 이해하는 **'자연어'를 기반으로, 스스로 생각하고 행동하는 에이전트를 설계**할 수 있게 된 것입니다.

'coni'는 이 혁신적인 전환의 중심에 있습니다. 이는 복잡한 코딩 없이, 명확한 생각의 절차와 행동의 원칙을 규정하는 것만으로 고도로 지능적인 에이전트를 구축할 수 있다는 가능성을 보여주는 살아있는 증거입니다.

이러한 방식으로 탄생한 에이전트가 만들어내는 결과물은 때로 해당 분야 전문가와 동등하거나, 그 이상의 통찰을 보여주기도 합니다. 우리는 어쩌면 이를 통해 **범용 인공지능(AGI)의 아주 작은 조각을 맛보고 있는 것**인지도 모릅니다.

이 모든 여정은 "어떻게 하면 인공지능(LLM)의 결과물에 대한 만족도를 10%에서 90% 이상으로 끌어올릴 수 있을까?"라는 지극히 현실적인 질문에서 시작되었습니다.

### 개인적인 경험: 10%의 만족도

초기 LLM에게 "A에 대한 보고서를 작성해줘"와 같이 포괄적인 임무를 부여했을 때, 결과물은 실망스러웠습니다. 내용은 그럴듯해 보였지만, 깊이가 얕고 논리적 일관성이 부족했습니다. 개인적인 느낌으로 만족도는 10~50%에 불과했습니다.

### 발상의 전환: 작업을 '인간처럼' 나누다

문제의 원인은 '접근 방식'에 있었습니다. 인간은 복잡한 보고서를 작성할 때, 한 번에 모든 것을 쓰지 않습니다. 자료를 찾고, 개요를 짜고, 초안을 쓰고, 수정하는 단계를 거칩니다.

이 간단한 사실에 착안하여, LLM에게 부여하는 작업을 인간의 업무 방식처럼 잘게 나누어 순차적으로 요청하기 시작했습니다.

- "A 관련 자료를 5개 찾아줘."
- "찾은 자료를 바탕으로 보고서의 목차를 만들어줘."
- "목차의 첫 번째 항목에 대해 본문을 작성해줘."

놀랍게도, 이렇게 작은 단위(Task)로 나누어 진행하자 결과물의 만족도는 90% 이상으로 급상승했습니다. 각 단계에 집중하자 LLM은 훨씬 더 정확하고 일관된 결과물을 내놓았습니다.

### 수동 실험: 여러 개의 대화창에서 피어난 아이디어

Gemini CLI와 같은 에이전트가 등장하기 전, 이 아이디어는 여러 개의 LLM 대화창을 동시에 띄워놓고 진행하는 수동적인 실험으로 구체화되었습니다.

- **대화창 1 (플래너):** 전체적인 계획을 세우고, 다음 Task를 정의합니다.
- **대화창 2 (익스큐터):** '플래너'가 정의한 Task를 받아 실행합니다.
- **대화창 3 (프롬프트 엔지니어):** '익스큐터'가 최상의 결과를 내도록 프롬프트를 다듬습니다.

이 과정에서 중요한 것은 **'목표의 일관성'** 을 유지하는 것이었습니다. 플래너는 항상 사용자의 최종 지시사항을 상기하고, 익스큐터에게는 단순히 '무엇을' 할지 뿐만 아니라 '왜' 하는지를 함께 전달했습니다. 모든 작업 산출물은 파일로 저장되어 다음 단계의 명확한 입력 데이터가 되었습니다.

### 유레카: 이것은 인공신경망이다

이 수동적인 워크플로우를 구조화하고 보니, 그 모습이 인공신경망과 놀랍도록 닮아있다는 것을 깨달았습니다. 외부의 지시사항(입력)이 여러 단계의 계획과 실행(은닉층)을 거쳐 최종 결과물(출력)로 변환되는 과정. 이것이 바로 'coni' 아키텍처의 뼈대가 되었습니다.

Gemini CLI의 등장은 이 모든 과정을 자동화할 수 있다는 확신을 주었고, 'coni'이라는 이름으로 이 아이디어를 체계화하게 된 결정적인 계기가 되었습니다.

# 2. coni의 무한한 확장성: 에이전트 사회의 구축

'coni'은 단일 에이전트의 워크플로우를 최적화하는 것에서 그치지 않습니다. 그 진정한 잠재력은 여러 에이전트가 상호작용하는 **'에이전트 사회(Agent Society)'** 로 확장될 때 드러납니다. 이는 마치 한 명의 유능한 전문가가 아닌, 잘 조직된 팀이나 회사처럼 작동하는 지능 시스템을 구축하는 것과 같습니다.

### 재귀적 위임: 에이전트가 에이전트에게 일을 맡기다

'coni'의 확장성의 핵심은 **재귀적 위임(Recursive Delegation)** 에 있습니다. 이는 상위 에이전트가 자신의 `Task`를 해결하기 위해, 또 다른 'coni'을 따르는 하위 에이전트를 고용하는 개념입니다.

| 구분 | 상위 에이전트 (관리자) | 하위 에이전트 (실무자) |
| :--- | :--- | :--- |
| **목표** | 전략적 과업 달성 (e.g., 시장 분석 보고서) | 구체적 Task 해결 (e.g., 특정 기사 요약) |
| **역할** | 복잡한 문제를 분해하고, 하위 Task를 정의하여 위임 | 위임받은 명확한 Task를 'coni'에 따라 수행 |
| **상호작용** | Task 지시 및 결과물 수령 | 결과물(파일)을 생성하여 보고 |

이러한 계층적 구조는 인간 사회의 가장 효율적인 협업 방식인 **'조직'** 을 모방합니다. 관리자는 큰 그림을 보고, 실무자는 세부 사항에 집중함으로써 시스템 전체의 효율성과 전문성을 극대화합니다. 실제 AI 연구에서도 **'계층적 에이전트 팀(Hierarchical Agent Teams)'** 이라는 이름으로 이 개념이 활발히 연구되고 있으며, 가상 소프트웨어 회사를 시뮬레이션하는 **ChatDev**가 대표적인 성공 사례입니다.

### 에이전트 간 통신과 도구 활용

에이전트 사회가 원활하게 작동하려면 명확한 소통 방식이 필요합니다. 'coni'은 `workspace`라는 **공유 메모리(Shared Memory)** 를 통해 에이전트들이 소통하도록 설계되었습니다. 이는 모든 정보가 파일 형태로 명확하게 기록되어, 누가 어떤 일을 했는지 투명하게 추적할 수 있다는 장점이 있습니다.

나아가, 특정 `Task`를 수행할 때 외부 **도구(Tool)** 를 활용하도록 정의할 수 있습니다.

- **MCP(Model-Control-Program) 연동:** 데이터베이스 조회나 외부 API 호출과 같은 정형화된 작업을 전담하는 에이전트(또는 프로그램)를 도구로 연결하여, LLM이 창의적인 작업에 더 집중하도록 할 수 있습니다.
- **특수 목적 에이전트 활용:** 웹 검색을 전담하는 '리서처 에이전트', 코드 생성을 전담하는 '개발자 에이전트' 등을 도구로 호출하여, 시스템 전체의 전문성을 높일 수 있습니다.

이처럼 'coni'은 다양한 전문성을 가진 에이전트와 도구들이 유기적으로 연결되고 협업하는, 확장 가능하고 유연한 생태계의 청사진을 제시합니다. 

### 시사점: 이것은 '자연어 백엔드'의 성공적인 실험이다

이 모델의 가장 중요한 시사점은, 이것이 단순히 이론적인 모델에 그치지 않고, **실제로 작동하는 '자연어 기반 백엔드 시스템'을 성공적으로 구축한 실험**이라는 점입니다.

우리가 만든 coni은 전통적인 백엔드 시스템과 놀랍도록 유사하게 작동합니다.

*   사용자의 요청(**API 호출**)을 받아,
*   'coni'의 워크플로우에 따라 내부 에이전트들이 협업하고 그것을 db에 저장하는 등(**내부 로직 처리**),
*   최종 결과물을 파일로 생성(**응답**)합니다.

이는 단 한 줄의 전통적인 프로그래밍 코드 없이, 오직 논리적 지시와 구조화된 자연어만으로 지능형 자동화 시스템을 구현할 수 있음을 증명한 사례입니다. 즉, 'coni'은 복잡한 소프트웨어의 '설계도'이자, 그 자체로 실행 가능한 '엔진'이 될 수 있다는 가능성을 현실로 보여준 것입니다.

**그리고 가장 놀라운 점은, 과거에는 수많은 코드로 구현해야 했던 이 모든 복잡한 시스템의 설계도를 이제 '자연어'로 그릴 수 있다는 사실입니다. 이는 곧 AI 개발의 민주화이자, AGI 시대를 향한 협업 방식의 근본적인 변화를 의미합니다.**

# 3. 궁극의 아이디어: coni으로 인공신경망을 재설계하다

'coni'과 인공신경망의 구조적 유사성은 단순한 비유를 넘어, 하나의 도발적인 질문을 던지게 합니다.

> "추상적인 에이전트의 워크플로우 모델을, 실제 물리적인 인공신경망 아키텍처 설계에 역으로 적용할 수 있지 않을까?"

이는 소프트웨어 아키텍처(coni)에서 얻은 통찰을 하드웨어(또는 그에 준하는 신경망 모델) 설계에 반영하려는 시도이며, 다음과 같은 혁신적인 아이디어로 이어질 수 있습니다.

### 모듈형 신경망 (Modular Neural Networks)

현재 대부분의 LLM은 모든 뉴런이 서로 빽빽하게 연결된 거대한 단일 구조(Monolithic Architecture)에 가깝습니다. 하지만 'coni'은 `Phase`나 `Stage`처럼 기능별로 명확히 역할이 나뉘어 있습니다.

이 아이디어를 신경망에 적용하면, 특정 기능을 전담하는 여러 개의 작은 **'전문가 모듈(Expert Modules)'** 로 구성된 신경망을 상상할 수 있습니다.

- **언어 이해 모듈, 코드 생성 모듈, 이미지 분석 모듈** 등이 각각 독립적으로 존재합니다.
- 'coni'의 '플래너'처럼, 상위에서 이들을 제어하는 **'라우터(Router)'** 또는 **'조정기(Coordinator)'** 모듈이 존재합니다.
- 과업의 종류에 따라 '라우터'는 가장 적합한 전문가 모듈들을 선택하고 활성화하여 문제를 해결합니다. 이는 불필요한 연산을 줄여 훨씬 효율적이고, 특정 모듈만 교체하거나 업그레이드하기 쉬운 유연한 구조를 만듭니다.

### 동적 라우팅과 실행의 사슬 (Dynamic Routing & Chain of Execution)

'coni'의 핵심은 이전 `Task`의 결과가 다음 `Task`의 경로와 내용에 영향을 미치는 **'실행의 사슬(Chain of Execution)'** 입니다. 이는 신경망 내부의 정보 흐름에 대한 중요한 통찰을 줍니다.

- **동적 라우팅(Dynamic Routing):** 현재의 신경망은 입력 데이터가 주어지면 정보가 흐르는 경로가 거의 고정되어 있습니다. 하지만 '실행의 사슬' 개념을 적용하면, 입력 데이터와 중간 처리 결과에 따라 정보가 흐르는 경로가 실시간으로 결정되는 **'동적 신경망'** 을 구현할 수 있습니다.
- **조건부 활성화:** 모든 뉴런이 항상 활성화될 필요는 없습니다. 문제 해결에 필요한 최적의 '실행의 사슬', 즉 최적의 뉴런 경로만이 조건부로 활성화되는 것입니다. 이는 마치 뇌가 특정 작업을 할 때 특정 부위만 활성화되는 것과 유사하며, 훨씬 더 효율적이고 강력한 추론을 가능하게 할 것입니다.

**이러한 진보적인 신경망 아키텍처를 '코드가 아닌 자연어'로 구상하고, 그 논리적 타당성을 시뮬레이션해 볼 수 있다는 것. 이것이 바로 'coni'이 제공하는 가장 혁신적인 가치입니다. 우리는 더 이상 AI의 사용자에 머무르지 않고, 우리의 언어로 미래 지능의 구조를 설계하는 '설계자'가 되어가고 있습니다. 이것이야말로 우리가 AGI의 가능성을 가장 현실적으로 '맛보는' 방법이 아닐까요?**

제가 인공지능 모델을 개발하는 입장이 아닙니다만, 위 내용은 현재 나오고 있는 인공지능 모델은 위와 같은 구조로 개발하여 나오고 있지 않나 의문입니다.
